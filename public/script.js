// Global variables
let processedQuestions = [];
let currentSection = 'home';
let currentTheme = 'light';
let userLocation = null;

// Weather API configuration
const WEATHER_API_KEY = '207e61419b36600ebe514b58917f5dd0'; // Thay th·∫ø b·∫±ng API key th·ª±c t·∫ø
const WEATHER_API_BASE = 'https://api.openweathermap.org/data/2.5';

// Initialize the application
document.addEventListener('DOMContentLoaded', function() {
    initializeApp();
});

function initializeApp() {
    updateTime();
    updateGreeting();
    updateTheme();
    initializeWeather();
    initializeFileUpload();
    
    // Update time every second
    setInterval(updateTime, 1000);
    
    // Update weather every 30 minutes
    setInterval(initializeWeather, 30 * 60 * 1000);
    
    // Update theme every minute
    setInterval(updateTheme, 60 * 1000);
}

// Time and greeting functions
function updateTime() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('vi-VN', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    });
    
    const timeElement = document.getElementById('current-time');
    if (timeElement) {
        timeElement.textContent = timeString;
    }
}

function updateGreeting() {
    const now = new Date();
    const hour = now.getHours();
    let greeting = '';
    
    if (hour >= 5 && hour < 12) {
        greeting = 'Ch√†o bu·ªïi s√°ng!';
    } else if (hour >= 12 && hour < 18) {
        greeting = 'Ch√†o bu·ªïi chi·ªÅu!';
    } else {
        greeting = 'Ch√†o bu·ªïi t·ªëi!';
    }
    
    const greetingElement = document.getElementById('greeting');
    if (greetingElement) {
        greetingElement.textContent = greeting;
    }
}

// Theme switching based on time
function updateTheme() {
    const now = new Date();
    const hour = now.getHours();
    
    // Day theme: 6 AM to 6 PM
    // Night theme: 6 PM to 6 AM
    const isDay = hour >= 6 && hour < 18;
    const newTheme = isDay ? 'light' : 'dark';
    
    if (newTheme !== currentTheme) {
        currentTheme = newTheme;
        applyTheme(newTheme);
    }
}

function applyTheme(theme) {
    const root = document.documentElement;
    
    if (theme === 'dark') {
        root.style.setProperty('--bg-primary', '#1a1a1a');
        root.style.setProperty('--bg-secondary', '#2d2d2d');
        root.style.setProperty('--bg-tertiary', '#404040');
        root.style.setProperty('--text-primary', '#f0f0f0');
        root.style.setProperty('--text-secondary', '#b0b0b0');
        root.style.setProperty('--text-muted', '#808080');
        root.style.setProperty('--border-color', '#404040');
        root.style.setProperty('--border-light', '#505050');
        root.style.setProperty('--shadow-color', 'rgba(0,0,0,0.3)');
        root.style.setProperty('--shadow-light', 'rgba(0,0,0,0.2)');
        root.style.setProperty('--card-bg', '#2d2d2d');
        root.style.setProperty('--input-bg', '#2d2d2d');
        
        // Update background animation for night
        document.body.classList.add('night-theme');
    } else {
        root.style.setProperty('--bg-primary', '#ffffff');
        root.style.setProperty('--bg-secondary', '#f8f9fa');
        root.style.setProperty('--bg-tertiary', '#f0f0f0');
        root.style.setProperty('--text-primary', '#333333');
        root.style.setProperty('--text-secondary', '#666666');
        root.style.setProperty('--text-muted', '#999999');
        root.style.setProperty('--border-color', '#e0e0e0');
        root.style.setProperty('--border-light', '#f0f0f0');
        root.style.setProperty('--shadow-color', 'rgba(0,0,0,0.1)');
        root.style.setProperty('--shadow-light', 'rgba(0,0,0,0.05)');
        root.style.setProperty('--card-bg', '#ffffff');
        root.style.setProperty('--card-bg', '#ffffff');
        root.style.setProperty('--input-bg', '#ffffff');
        
        // Update background animation for day
        document.body.classList.remove('night-theme');
    }
}

// Weather functions with real API
async function initializeWeather() {
    try {
        // First try to get user's location
        if (!userLocation) {
            await getUserLocation();
        }
        
        if (userLocation) {
            // Get weather data from API
            const weatherData = await getWeatherData(userLocation.lat, userLocation.lon);
            updateWeatherDisplay(weatherData);
        } else {
            // Fallback to mock data if location not available
            const mockWeather = getMockWeather();
            updateWeatherDisplay(mockWeather);
        }
    } catch (error) {
        console.error('Error fetching weather:', error);
        
        // Show specific error message for API issues
        if (error.message.includes('API Key')) {
            updateWeatherDisplay({
                temperature: '--¬∞C',
                description: 'L·ªói API Key',
                humidity: '--%',
                windSpeed: '-- km/h',
                icon: 'üîë',
                location: 'API Key c·∫ßn ƒë∆∞·ª£c k√≠ch ho·∫°t'
            });
            
            // Show notification with detailed error
            showError(`L·ªói th·ªùi ti·∫øt: ${error.message}`);
        } else if (error.message.includes('v∆∞·ª£t qu√° gi·ªõi h·∫°n')) {
            updateWeatherDisplay({
                temperature: '--¬∞C',
                description: 'Qu√° gi·ªõi h·∫°n API',
                humidity: '--%',
                windSpeed: '-- km/h',
                icon: '‚è∞',
                location: 'Th·ª≠ l·∫°i sau'
            });
        } else {
            updateWeatherDisplay({
                temperature: '--¬∞C',
                description: 'Kh√¥ng th·ªÉ t·∫£i th·ªùi ti·∫øt',
                humidity: '--%',
                windSpeed: '-- km/h',
                icon: 'üå§Ô∏è',
                location: 'V·ªã tr√≠ kh√¥ng x√°c ƒë·ªãnh'
            });
        }
    }
}

// Test weather API directly
async function testWeatherAPI() {
    try {
        // Show loading state
        updateWeatherDisplay({
            temperature: '--¬∞C',
            description: 'ƒêang test API...',
            humidity: '--%',
            windSpeed: '-- km/h',
            icon: 'üîç',
            location: 'Ki·ªÉm tra API Key'
        });
        
        // Test with Hanoi coordinates
        const testLat = 21.0285;
        const testLon = 105.8542;
        
        const testResponse = await fetch(
            `${WEATHER_API_BASE}/weather?lat=${testLat}&lon=${testLon}&appid=${WEATHER_API_KEY}&units=metric&lang=vi`
        );
        
        if (testResponse.ok) {
            const testData = await testResponse.json();
            showSuccess('‚úÖ API Key ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng!');
            
            // Update display with test data
            updateWeatherDisplay({
                temperature: `${Math.round(testData.main.temp)}¬∞C`,
                description: getWeatherDescription(testData.weather[0].id, testData.weather[0].main),
                humidity: `${testData.main.humidity}%`,
                windSpeed: `${Math.round(testData.wind.speed * 3.6)} km/h`,
                icon: getWeatherIcon(testData.weather[0].id, testData.weather[0].icon),
                location: 'H√† N·ªôi (Test)'
            });
        } else {
            const errorData = await testResponse.json();
            throw new Error(`API Test failed: ${errorData.message || errorData.cod}`);
        }
        
    } catch (error) {
        console.error('API Test error:', error);
        showError(`Test API th·∫•t b·∫°i: ${error.message}`);
        
        // Show error state
        updateWeatherDisplay({
            temperature: '--¬∞C',
            description: 'Test th·∫•t b·∫°i',
            humidity: '--%',
            windSpeed: '-- km/h',
            icon: '‚ùå',
            location: 'API Key c√≥ v·∫•n ƒë·ªÅ'
        });
    }
}

// Get user's current location
function getUserLocation() {
    return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
            reject(new Error('Geolocation kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£'));
            return;
        }
        
        // Show loading state
        updateWeatherDisplay({
            temperature: '--¬∞C',
            description: 'ƒêang l·∫•y v·ªã tr√≠...',
            humidity: '--%',
            windSpeed: '-- km/h',
            icon: 'üìç',
            location: 'ƒêang x√°c ƒë·ªãnh v·ªã tr√≠'
        });
        
        navigator.geolocation.getCurrentPosition(
            (position) => {
                userLocation = {
                    lat: position.coords.latitude,
                    lon: position.coords.longitude
                };
                console.log('User location:', userLocation);
                resolve(userLocation);
            },
            (error) => {
                console.error('Geolocation error:', error);
                reject(error);
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 300000 // 5 minutes
            }
        );
    });
}

// Get weather data from OpenWeatherMap API
async function getWeatherData(lat, lon) {
    try {
        // Get current weather
        const weatherResponse = await fetch(
            `${WEATHER_API_BASE}/weather?lat=${lat}&lon=${lon}&appid=${WEATHER_API_KEY}&units=metric&lang=vi`
        );
        
        if (!weatherResponse.ok) {
            const errorData = await weatherResponse.json();
            console.error('Weather API error:', errorData);
            
            if (errorData.cod === 401) {
                throw new Error('API Key kh√¥ng h·ª£p l·ªá ho·∫∑c ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t. Vui l√≤ng ki·ªÉm tra l·∫°i ho·∫∑c ƒë·ª£i v√†i gi·ªù ƒë·ªÉ API key ƒë∆∞·ª£c k√≠ch ho·∫°t.');
            } else if (errorData.cod === 429) {
                throw new Error('ƒê√£ v∆∞·ª£t qu√° gi·ªõi h·∫°n API calls. Vui l√≤ng th·ª≠ l·∫°i sau.');
            } else {
                throw new Error(`L·ªói API th·ªùi ti·∫øt: ${errorData.message || errorData.cod}`);
            }
        }
        
        const weatherData = await weatherResponse.json();
        
        // Get city name from reverse geocoding
        const cityResponse = await fetch(
            `https://api.openweathermap.org/geo/1.0/reverse?lat=${lat}&lon=${lon}&limit=1&appid=${WEATHER_API_KEY}&lang=vi`
        );
        
        let cityName = 'V·ªã tr√≠ hi·ªán t·∫°i';
        if (cityResponse.ok) {
            const cityData = await cityResponse.json();
            if (cityData.length > 0) {
                cityName = cityData[0].name;
                if (cityData[0].state) {
                    cityName += `, ${cityData[0].state}`;
                }
                if (cityData[0].country) {
                    cityName += `, ${cityData[0].country}`;
                }
            }
        }
        
        // Process weather data
        const processedWeather = {
            temperature: `${Math.round(weatherData.main.temp)}¬∞C`,
            description: getWeatherDescription(weatherData.weather[0].id, weatherData.weather[0].main),
            humidity: `${weatherData.main.humidity}%`,
            windSpeed: `${Math.round(weatherData.wind.speed * 3.6)} km/h`, // Convert m/s to km/h
            icon: getWeatherIcon(weatherData.weather[0].id, weatherData.weather[0].icon),
            location: cityName,
            feelsLike: `${Math.round(weatherData.main.feels_like)}¬∞C`,
            pressure: `${weatherData.main.pressure} hPa`,
            visibility: weatherData.visibility ? `${Math.round(weatherData.visibility / 1000)} km` : '-- km'
        };
        
        return processedWeather;
        
    } catch (error) {
        console.error('Error fetching weather data:', error);
        throw error;
    }
}

// Get weather description in Vietnamese
function getWeatherDescription(weatherId, weatherMain) {
    const descriptions = {
        200: 'Gi√¥ng b√£o v·ªõi m∆∞a nh·ªè',
        201: 'Gi√¥ng b√£o v·ªõi m∆∞a',
        202: 'Gi√¥ng b√£o v·ªõi m∆∞a l·ªõn',
        210: 'Gi√¥ng b√£o nh·∫π',
        211: 'Gi√¥ng b√£o',
        212: 'Gi√¥ng b√£o m·∫°nh',
        221: 'Gi√¥ng b√£o d·ªØ d·ªôi',
        230: 'Gi√¥ng b√£o v·ªõi m∆∞a ph√πn nh·∫π',
        231: 'Gi√¥ng b√£o v·ªõi m∆∞a ph√πn',
        232: 'Gi√¥ng b√£o v·ªõi m∆∞a ph√πn m·∫°nh',
        300: 'M∆∞a ph√πn nh·∫π',
        301: 'M∆∞a ph√πn',
        302: 'M∆∞a ph√πn m·∫°nh',
        310: 'M∆∞a ph√πn nh·∫π',
        311: 'M∆∞a ph√πn',
        312: 'M∆∞a ph√πn m·∫°nh',
        313: 'M∆∞a v√† m∆∞a ph√πn',
        314: 'M∆∞a l·ªõn v√† m∆∞a ph√πn',
        321: 'M∆∞a ph√πn',
        500: 'M∆∞a nh·∫π',
        501: 'M∆∞a v·ª´a',
        502: 'M∆∞a c∆∞·ªùng ƒë·ªô m·∫°nh',
        503: 'M∆∞a r·∫•t m·∫°nh',
        504: 'M∆∞a c·ª±c m·∫°nh',
        511: 'M∆∞a ƒë√°',
        520: 'M∆∞a r√†o nh·∫π',
        521: 'M∆∞a r√†o',
        522: 'M∆∞a r√†o m·∫°nh',
        531: 'M∆∞a r√†o d·ªØ d·ªôi',
        600: 'Tuy·∫øt nh·∫π',
        601: 'Tuy·∫øt',
        602: 'Tuy·∫øt d√†y',
        611: 'M∆∞a tuy·∫øt',
        612: 'M∆∞a tuy·∫øt nh·∫π',
        613: 'M∆∞a tuy·∫øt',
        615: 'M∆∞a nh·∫π v√† tuy·∫øt',
        616: 'M∆∞a v√† tuy·∫øt',
        620: 'M∆∞a tuy·∫øt nh·∫π',
        621: 'M∆∞a tuy·∫øt',
        622: 'M∆∞a tuy·∫øt m·∫°nh',
        701: 'S∆∞∆°ng m√π',
        711: 'Kh√≥i m√π',
        721: 'S∆∞∆°ng m√π nh·∫π',
        731: 'C√°t bay',
        741: 'S∆∞∆°ng m√π',
        751: 'C√°t',
        761: 'B·ª•i',
        762: 'Tro n√∫i l·ª≠a',
        771: 'Gi√≥ m·∫°nh',
        781: 'L·ªëc xo√°y',
        800: 'Tr·ªùi quang',
        801: '√çt m√¢y',
        802: 'M√¢y r·∫£i r√°c',
        803: 'M√¢y c·ª•m',
        804: 'M√¢y d√†y'
    };
    
    return descriptions[weatherId] || weatherMain;
}

// Get weather icon based on weather condition
function getWeatherIcon(weatherId, iconCode) {
    const icons = {
        200: '‚õàÔ∏è', 201: '‚õàÔ∏è', 202: '‚õàÔ∏è', 210: '‚õàÔ∏è', 211: '‚õàÔ∏è', 212: '‚õàÔ∏è', 221: '‚õàÔ∏è',
        230: '‚õàÔ∏è', 231: '‚õàÔ∏è', 232: '‚õàÔ∏è',
        300: 'üå¶Ô∏è', 301: 'üå¶Ô∏è', 302: 'üå¶Ô∏è', 310: 'üå¶Ô∏è', 311: 'üå¶Ô∏è', 312: 'üå¶Ô∏è',
        313: 'üå¶Ô∏è', 314: 'üå¶Ô∏è', 321: 'üå¶Ô∏è',
        500: 'üåßÔ∏è', 501: 'üåßÔ∏è', 502: 'üåßÔ∏è', 503: 'üåßÔ∏è', 504: 'üåßÔ∏è', 511: 'üßä',
        520: 'üåßÔ∏è', 521: 'üåßÔ∏è', 522: 'üåßÔ∏è', 531: 'üåßÔ∏è',
        600: '‚ùÑÔ∏è', 601: '‚ùÑÔ∏è', 602: '‚ùÑÔ∏è', 611: 'üå®Ô∏è', 612: 'üå®Ô∏è', 613: 'üå®Ô∏è',
        615: 'üå®Ô∏è', 616: 'üå®Ô∏è', 620: 'üå®Ô∏è', 621: 'üå®Ô∏è', 622: 'üå®Ô∏è',
        701: 'üå´Ô∏è', 711: 'üå´Ô∏è', 721: 'üå´Ô∏è', 731: 'üå´Ô∏è', 741: 'üå´Ô∏è',
        751: 'üå´Ô∏è', 761: 'üå´Ô∏è', 762: 'üå´Ô∏è', 771: 'üí®', 781: 'üå™Ô∏è',
        800: '‚òÄÔ∏è', 801: 'üå§Ô∏è', 802: '‚õÖ', 803: '‚òÅÔ∏è', 804: '‚òÅÔ∏è'
    };
    
    return icons[weatherId] || 'üå§Ô∏è';
}

// Fallback mock weather function
function getMockWeather() {
    const now = new Date();
    const hour = now.getHours();
    
    // Simulate different weather based on time
    if (hour >= 6 && hour < 18) {
        // Day time
        return {
            temperature: `${Math.floor(Math.random() * 15) + 20}¬∞C`,
            description: 'N·∫Øng ƒë·∫πp',
            humidity: `${Math.floor(Math.random() * 30) + 50}%`,
            windSpeed: `${Math.floor(Math.random() * 20) + 5} km/h`,
            icon: '‚òÄÔ∏è',
            location: 'V·ªã tr√≠ m·∫´u (ban ng√†y)'
        };
    } else {
        // Night time
        return {
            temperature: `${Math.floor(Math.random() * 10) + 15}¬∞C`,
            description: 'M√°t m·∫ª',
            humidity: `${Math.floor(Math.random() * 20) + 60}%`,
            windSpeed: `${Math.floor(Math.random() * 15) + 3} km/h`,
            icon: 'üåô',
            location: 'V·ªã tr√≠ m·∫´u (ban ƒë√™m)'
        };
    }
}

function updateWeatherDisplay(weather) {
    const iconElement = document.getElementById('weather-icon');
    const tempElement = document.getElementById('temperature');
    const descElement = document.getElementById('weather-desc');
    const humidityElement = document.getElementById('humidity');
    const windElement = document.getElementById('wind-speed');
    
    if (iconElement) iconElement.textContent = weather.icon;
    if (tempElement) tempElement.textContent = weather.temperature;
    if (descElement) descElement.textContent = weather.description;
    if (humidityElement) humidityElement.textContent = weather.humidity;
    if (windElement) windElement.textContent = weather.windSpeed;
    
    // Update location if available
    if (weather.location) {
        const locationElement = document.getElementById('weather-location');
        if (locationElement) {
            locationElement.textContent = weather.location;
        }
    }
}

// Navigation functions
function showHome() {
    currentSection = 'home';
    document.getElementById('home-section').style.display = 'block';
    document.getElementById('question-processor-section').style.display = 'none';
    
    // Update navigation active state
    document.querySelectorAll('.nav-link').forEach(link => {
        link.classList.remove('active');
    });
    document.querySelector('.nav-link[onclick="showHome()"]').classList.add('active');
}

function showQuestionProcessor() {
    currentSection = 'question-processor';
    document.getElementById('home-section').style.display = 'none';
    document.getElementById('question-processor-section').style.display = 'block';
    
    // Update navigation active state
    document.querySelectorAll('.nav-link').forEach(link => {
        link.classList.remove('active');
    });
    document.querySelector('.nav-link[onclick="showQuestionProcessor()"]').classList.add('active');
}

function showHelp() {
    alert('H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng:\n\n1. Ch·ªçn "JSON Question Process" t·ª´ menu\n2. T·∫£i l√™n file JSON ho·∫∑c nh·∫≠p d·ªØ li·ªáu tr·ª±c ti·∫øp\n3. Ch·ªçn c√°c t√πy ch·ªçn x·ª≠ l√Ω\n4. Nh·∫•n "X·ª≠ l√Ω d·ªØ li·ªáu"\n5. Xu·∫•t k·∫øt qu·∫£ ra Word ho·∫∑c Text');
}

// File upload functions
function initializeFileUpload() {
    const fileUploadArea = document.getElementById('fileUploadArea');
    const fileInput = document.getElementById('fileInput');
    
    if (fileUploadArea && fileInput) {
        // Click to upload
        fileUploadArea.addEventListener('click', () => {
            fileInput.click();
        });
        
        // Drag and drop
        fileUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileUploadArea.style.borderColor = '#764ba2';
            fileUploadArea.style.background = 'var(--bg-secondary)';
        });
        
        fileUploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            fileUploadArea.style.borderColor = '#667eea';
            fileUploadArea.style.background = 'var(--bg-tertiary)';
        });
        
        fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUploadArea.style.borderColor = '#667eea';
            fileUploadArea.style.background = 'var(--bg-tertiary)';
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileUpload(files[0]);
            }
        });
        
        // File input change
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileUpload(e.target.files[0]);
            }
        });
    }
}

function handleFileUpload(file) {
    if (file.type === 'application/json' || file.name.endsWith('.json')) {
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const content = e.target.result;
                document.getElementById('jsonInput').value = content;
                showSuccess('File ƒë√£ ƒë∆∞·ª£c t·∫£i l√™n th√†nh c√¥ng!');
            } catch (error) {
                showError('L·ªói khi ƒë·ªçc file: ' + error.message);
            }
        };
        reader.readAsText(file);
    } else {
        showError('Vui l√≤ng ch·ªçn file JSON h·ª£p l·ªá');
    }
}

// Data processing functions
function processData() {
    const jsonInput = document.getElementById('jsonInput').value.trim();
    
    if (!jsonInput) {
        showError('Vui l√≤ng nh·∫≠p d·ªØ li·ªáu JSON ho·∫∑c t·∫£i file l√™n');
        return;
    }
    
    try {
        const data = JSON.parse(jsonInput);
        const options = {
            removeDuplicates: document.getElementById('removeDuplicates').checked,
            filterImages: document.getElementById('filterImages').checked,
            cleanHtml: document.getElementById('cleanHtml').checked
        };
        
        // Send to server for processing
        fetch('/upload', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ data, options })
        })
        .then(response => response.json())
        .then(result => {
            if (result.success) {
                processedQuestions = result.questions;
                displayResults(result);
                showSuccess('D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω th√†nh c√¥ng!');
            } else {
                showError('L·ªói khi x·ª≠ l√Ω d·ªØ li·ªáu: ' + result.error);
            }
        })
        .catch(error => {
            showError('L·ªói k·∫øt n·ªëi: ' + error.message);
        });
        
    } catch (error) {
        showError('D·ªØ li·ªáu JSON kh√¥ng h·ª£p l·ªá: ' + error.message);
    }
}

function displayResults(result) {
    const resultsSection = document.getElementById('resultsSection');
    const totalQuestions = document.getElementById('totalQuestions');
    const processedQuestions = document.getElementById('processedQuestions');
    const duplicatesRemoved = document.getElementById('duplicatesRemoved');
    const questionsList = document.getElementById('questionsList');
    
    if (resultsSection) resultsSection.style.display = 'block';
    if (totalQuestions) totalQuestions.textContent = result.totalProcessed || 0;
    if (processedQuestions) processedQuestions.textContent = result.questions.length || 0;
    if (duplicatesRemoved) duplicatesRemoved.textContent = result.duplicatesRemoved || 0;
    
    if (questionsList) {
        questionsList.innerHTML = '';
        result.questions.forEach((question, index) => {
            const questionDiv = document.createElement('div');
            questionDiv.className = 'question-item';
            questionDiv.innerHTML = `
                <div class="question-content">
                    <strong>C√¢u ${question.id}:</strong> ${question.question}
                </div>
                <div class="answers-list">
                    ${question.answers.map((answer, ansIndex) => 
                        `<div class="answer-item">${String.fromCharCode(65 + ansIndex)}. ${answer.answer}</div>`
                    ).join('')}
                </div>
            `;
            questionsList.appendChild(questionDiv);
        });
    }
}

// Export functions
function showExportModal() {
    if (processedQuestions.length === 0) {
        showError('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t');
        return;
    }
    document.getElementById('exportModal').style.display = 'block';
}

function closeExportModal() {
    document.getElementById('exportModal').style.display = 'none';
}

function exportToTXT() {
    if (processedQuestions.length === 0) {
        showError('Kh√¥ng c√≥ c√¢u h·ªèi ƒë·ªÉ xu·∫•t.');
        return;
    }
    
    let txtContent = 'DANH S√ÅCH C√ÇU H·ªéI\n';
    txtContent += '='.repeat(50) + '\n\n';
    
    processedQuestions.forEach((question, index) => {
        txtContent += `C√¢u ${question.id}:\n`;
        txtContent += `${question.question}\n\n`;
        txtContent += 'ƒê√°p √°n:\n';
        
        question.answers.forEach((answer, ansIndex) => {
            const option = String.fromCharCode(65 + ansIndex);
            txtContent += `${option}. ${answer.answer}\n`;
        });
        
        txtContent += '\n' + '-'.repeat(30) + '\n\n';
    });
    
    const dataBlob = new Blob([txtContent], { type: 'text/plain;charset=utf-8' });
    downloadFile(dataBlob, 'questions.txt');
    closeExportModal();
}

function exportToWord() {
    if (processedQuestions.length === 0) {
        showError('Kh√¥ng c√≥ c√¢u h·ªèi ƒë·ªÉ xu·∫•t.');
        return;
    }
    
    // Send request to server to generate Word document
    fetch('/export-word', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(processedQuestions)
    })
    .then(async response => {
        if (!response.ok) {
            const message = await response.text().catch(() => '');
            throw new Error(message || 'Kh√¥ng th·ªÉ t·∫°o t√†i li·ªáu xu·∫•t');
        }
        const contentType = response.headers.get('content-type') || '';
        const disposition = response.headers.get('content-disposition') || '';
        const blob = await response.blob();

        // Determine filename based on content type or header
        let filename = 'questions.docx';
        if (contentType.includes('text/plain')) {
            filename = 'questions.txt';
        } else {
            const match = /filename="?([^";]+)"?/i.exec(disposition);
            if (match && match[1]) filename = match[1];
        }

        downloadFile(blob, filename);
        closeExportModal();
        showSuccess('T√†i li·ªáu ƒë√£ ƒë∆∞·ª£c xu·∫•t th√†nh c√¥ng!');
    })
    .catch(error => {
        showError('L·ªói khi xu·∫•t Word: ' + error.message);
    });
}

// Utility functions
function downloadFile(blob, filename) {
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
}

function showError(message) {
    // Create error notification
    const notification = document.createElement('div');
    notification.className = 'notification error';
    notification.innerHTML = `
        <i class="fas fa-exclamation-circle"></i>
        <span>${message}</span>
    `;
    
    showNotification(notification);
}

function showSuccess(message) {
    // Create success notification
    const notification = document.createElement('div');
    notification.className = 'notification success';
    notification.innerHTML = `
        <i class="fas fa-check-circle"></i>
        <span>${message}</span>
    `;
    
    showNotification(notification);
}

function showNotification(notification) {
    // Add notification styles
    notification.style.cssText = `
        position: fixed;
        top: 100px;
        right: 20px;
        padding: 1rem 1.5rem;
        border-radius: 10px;
        color: white;
        font-weight: 500;
        z-index: 3000;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        animation: slideInRight 0.3s ease;
        max-width: 400px;
    `;
    
    if (notification.className.includes('error')) {
        notification.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%)';
    } else {
        notification.style.background = 'linear-gradient(135deg, #51cf66 0%, #40c057 100%)';
    }
    
    document.body.appendChild(notification);
    
    // Remove after 5 seconds
    setTimeout(() => {
        notification.style.animation = 'slideOutRight 0.3s ease';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }, 5000);
}

// Add CSS animations and theme-specific styles
const style = document.createElement('style');
style.textContent = `
    @keyframes slideInRight {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    @keyframes slideOutRight {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(100%);
            opacity: 0;
        }
    }
    
    .question-item {
        background: var(--card-bg);
        padding: 1.5rem;
        margin: 1rem 0;
        border-radius: 10px;
        box-shadow: 0 2px 10px var(--shadow-color);
        border-left: 4px solid #667eea;
        color: var(--text-primary);
    }
    
    .question-content {
        margin-bottom: 1rem;
        font-size: 1.1rem;
        line-height: 1.6;
        color: var(--text-primary);
    }
    
    .answers-list {
        margin-left: 1rem;
    }
    
    .answer-item {
        padding: 0.5rem 0;
        border-bottom: 1px solid var(--border-light);
        color: var(--text-secondary);
    }
    
    .answer-item:last-child {
        border-bottom: none;
    }
    
    /* Theme-specific background animations */
    .night-theme .background-animation .stars {
        opacity: 0.6;
    }
    
    .night-theme .background-animation .clouds {
        opacity: 0.05;
    }
    
    .night-theme .hero-container {
        background: rgba(45, 45, 45, 0.1);
        border-color: rgba(255, 255, 255, 0.1);
    }
    
    /* Smooth theme transitions */
    * {
        transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }
`;
document.head.appendChild(style);
